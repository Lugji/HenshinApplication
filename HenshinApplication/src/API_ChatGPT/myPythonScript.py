from openai import OpenAI

# Initialize OpenAI client
client = OpenAI(api_key="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")

response = client.chat.completions.create(
  model="gpt-3.5-turbo",
  temperature=0.3,
  messages=[{"role": "system", "content": "You are an assistant specialized in conflict and dependency detection in rule-based graph transformation."},
  {"role": "user", "content": "User: **Objective**:\nAnalyze a set of Cypher queries for potential conflicts within a graph database context. Conflicts are identified based on interactions between queries that lead to alteration or removal of graph elements, which could affect the outcome of subsequent queries.\n\n**Conflict Criteria**:\n1. **Deletion Conflict**: Occurs when a query deletes a graph element (node or relationship) that is required by another query for its `MATCH` condition.\n2. **Creation-Deletion Conflict**: Arises when a query creates an edge incident to a node that is targeted for deletion by another query.\n3. **Simultaneous Deletion Conflict**: Happens when two queries attempt to delete the same graph elements.\n\n**Graph Elements**:\n- **Nodes**: Represent entities such as Bank, Account, Client, and Manager.\n- **Relationships**: Indicate connections between nodes, such as CLIENTS, ACCOUNTS, MANAGERS, and OWNER.\n\n**Tasks**:\n1. **Identify Relationships**: For each query, list the nodes and relationships directly involved in `CREATE` or `DELETE` actions.\n2. **Analyze Interactions**: Examine the potential impact of each query on the others, focusing on the conflict criteria outlined.\n3. **Matrix Representation**: Represent the analysis results as a binary matrix, where rows and columns correspond to the queries in order. Use \"1\" to indicate a conflict between two queries and \"0\" for no conflict.\n\n**Enhancements**:\n- Provide brief descriptions of the purpose behind each query to contextualize the analysis.\n- Consider edge cases, such as indirect effects a query might have due to changes in the graph structure, which could influence the applicability of other queries.\n- Include examples of specific scenarios where conflicts might arise, based on the graph elements involved.\n\n** Queries**:\n\nCypher Query for rule createAccount:\nMATCH (bank1:Bank)-[a:CLIENTS]->(client1:Client), (bank1)-[b:MANAGERS]->(manager1:Manager)-[c:CLIENTS]->(client1)\nWHERE NOT (bank1)-[:ACCOUNTS]->(:Account{id: 'accountId'})\nCREATE (account1:Account), (bank1)-[d:ACCOUNTS]->(account1), (client1)-[e:ACCOUNTS]->(account1)\n\nCypher Query for rule deleteAccount:\nMATCH (bank1:Bank)-[a:MANAGERS]->(manager1:Manager)-[c:CLIENTS]->(client1:Client), (bank1)-[b:CLIENTS]->(client1), (bank1)-[d:ACCOUNTS]->(account1:Account)-[e:OWNER]->(client1)\nDELETE d, e, account1\n\nCypher Query for rule assignManagerToAClient:\nMATCH (bank1:Bank)-[a:CLIENTS]->(client1:Client), (bank1)-[b:MANAGERS]->(manager1:Manager)\nCREATE (manager1)-[c:CLIENTS]->(client1)\n\nCypher Query for rule moveAccountFromOneClientToAnother:\nMATCH (bank1:Bank)-[a:ACCOUNTS]->(account1:Account)-[d:OWNER]->(client1:Client), (bank1)-[b:CLIENTS]->(client2:Client), (bank1)-[c:CLIENTS]->(client1)\nDELETE d\nCREATE (account1)-[e:OWNER]->(client2)\n\nCypher Query for rule deleteManager:\nMATCH (bank1:Bank)-[a:MANAGERS]->(manager1:Manager)-[b:CLIENTS]->(client1:Client), (bank1)-[c:CLIENTS]->(client1)\nDELETE a, b, manager1\n\nCypher Query for rule createAClientWithAnAccAndManager:\nMATCH (bank1:Bank)-[a:MANAGERS]->(manager1:Manager)\nCREATE (client1:Client), (account1:Account), (bank1)-[b:CLIENTS]->(client1), (client1)-[c:ACCOUNTS]->(account1), (manager1)-[d:CLIENTS]->(client1), (bank1)-[e:ACCOUNTS]->(account1)\n\n"},],
)
response_text = response.choices[0].message.content
print(response_text)
